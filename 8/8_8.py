# Импорт необходимых библиотек:
import cv2  # OpenCV для работы с изображениями и алгоритмами детекции/сопоставления
import numpy as np  # NumPy для работы с массивами и математическими операциями
import matplotlib.pyplot as plt  # Для построения графиков и гистограмм

# ------------------------- ШАГ 1: Загрузка изображений и подготовка -------------------------
# Задаём пути к изображениям (замените на ваши пути)
img1_path = 'images/1.jpg'
img2_path = 'images/2.jpg'

# Загружаем изображения
img1 = cv2.imread(img1_path)
img2 = cv2.imread(img2_path)

# Проверяем успешную загрузку
if img1 is None:
    raise IOError(f"Не удалось загрузить изображение: {img1_path}")
if img2 is None:
    raise IOError(f"Не удалось загрузить изображение: {img2_path}")

# Преобразуем изображения в оттенки серого (ORB работает с одноканальными изображениями)
gray1 = cv2.cvtColor(img1, cv2.COLOR_BGR2GRAY)
gray2 = cv2.cvtColor(img2, cv2.COLOR_BGR2GRAY)

# ------------------------- ШАГ 2: Обнаружение ключевых точек и вычисление дескрипторов -------------------------
# Инициализируем детектор ORB
orb = cv2.ORB_create(nfeatures=500)

# Обнаруживаем ключевые точки и вычисляем дескрипторы для каждого изображения
kp1, des1 = orb.detectAndCompute(gray1, None)
kp2, des2 = orb.detectAndCompute(gray2, None)

# Если ключевые точки не найдены, генерируем ошибку
if des1 is None or des2 is None:
    raise ValueError("Не удалось обнаружить ключевые точки в одном из изображений.")

# ------------------------- ШАГ 3: Сопоставление дескрипторов -------------------------
# Создаём объект BFMatcher с Hamming-расстоянием (подходит для бинарных дескрипторов ORB)
bf = cv2.BFMatcher(cv2.NORM_HAMMING, crossCheck=True)

# Производим сопоставление дескрипторов между изображениями
matches = bf.match(des1, des2)

# Сортируем совпадения по расстоянию (меньшее расстояние означает лучшее совпадение)
matches = sorted(matches, key=lambda m: m.distance)

# ------------------------- ШАГ 4: Анализ параллельности линий -------------------------
# Для каждого совпадения вычисляем вектор, соединяющий соответствующие ключевые точки
# и определяем угол этого вектора

angles = []  # список для хранения углов (в градусах)
for m in matches:
    # Координаты ключевой точки в первом изображении
    x1, y1 = kp1[m.queryIdx].pt
    # Координаты соответствующей ключевой точки во втором изображении
    x2, y2 = kp2[m.trainIdx].pt

    # Вычисляем компоненты вектора смещения
    dx = x2 - x1
    dy = y2 - y1

    # Вычисляем угол вектора в радианах с помощью arctan2 (учитывает знак)
    angle_rad = np.arctan2(dy, dx)

    # Преобразуем угол в градусы
    angle_deg = np.degrees(angle_rad)
    angles.append(angle_deg)

angles = np.array(angles)

# Вычисляем среднее значение угла и стандартное отклонение
mean_angle = np.mean(angles)
std_angle = np.std(angles)
print(f"Средний угол: {mean_angle:.2f} градусов")
print(f"Стандартное отклонение углов: {std_angle:.2f} градусов")

# Интерпретация:
# Низкое стандартное отклонение означает, что линии имеют схожее направление и, следовательно, являются параллельными.

# ------------------------- ШАГ 5: Визуализация результатов -------------------------
# 5.1. Визуализация сопоставленных ключевых точек
# Рисуем линии, соединяющие ключевые точки, между двумя изображениями, расположенными рядом
img_matches = cv2.drawMatches(img1, kp1, img2, kp2, matches, None, flags=2)

plt.figure(figsize=(12, 6))
plt.imshow(cv2.cvtColor(img_matches, cv2.COLOR_BGR2RGB))
plt.title("Сопоставление ключевых точек между изображениями")
plt.axis("off")
plt.show()

# 5.2. Построение гистограммы распределения углов
plt.figure(figsize=(10, 6))
plt.hist(angles, bins=30, alpha=0.7, color='green', edgecolor='black')
plt.title("Гистограмма углов векторов, соединяющих соответствующие ключевые точки")
plt.xlabel("Угол (градусы)")
plt.ylabel("Частота")
plt.grid(True)
plt.show()
